<html>

<head>
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <script src="https://hammerjs.github.io/dist/hammer.min.js"></script>
  <script src="https://unpkg.com/aframe-text-geometry-component@0.5.1/dist/aframe-text-geometry-component.min.js"></script>
  <script>
    modelss = ['na' , 'h'];
    modelsObjects = [];
    modelsDesc = [];
    AFRAME.registerComponent("controller", {
      init: function () {
        this.modelVisible = false;
        // track markerFound/markerLost
        this.el.addEventListener("markerFound", () => this.modelVisible = true);
        this.el.addEventListener("markerLost", () => this.modelVisible = false);
        // grab the model reference
        document.querySelector("[gltf-model]").addEventListener("model-loaded", evt => {
                  for (const model of modelss) {
                    this.model = document.querySelector("#" + model + "-model").object3D;
                    modelsObjects.push(this.model);
                    this.desc = document.querySelector("#" + model + "-desc").object3D;
                    modelsDesc.push(this.desc)
                  }
                }
          )


        // hammerjs input helper
        const hammertime = new Hammer(document.body);

        // scale
        // scale is tricky, because it resets

        var currentScale = 1;
        hammertime.get('pinch').set({ enable: true });
        hammertime.on("pinchstart", (ev) => {
          currentScale = this.model.scale.x;
          currentScaleText = this.desc.scale.x;
        })
        hammertime.on("pinchend", (ev) => {
          if (!this.modelVisible) return;
          modelsObjects.forEach((x) => x.scale.multiplyScalar(0).addScalar(ev.scale * currentScale));

          modelsDesc.forEach((x) => x.scale.multiplyScalar(0).addScalar(ev.scale * currentScaleText));
        });

        // rotation
        // pan left/right for rotation
        this.isPanning = false;
        hammertime.on("panleft", () => {
          if (!this.modelVisible) return;
          this.isPanning = true
          // this.mesh.rotation.y -= 4 * Math.PI / 360;
          modelsObjects.forEach((x) => x.rotation.y -= 4 * Math.PI / 360 )
        })

        hammertime.on("panright", () => {
          if (!this.modelVisible) return;
          this.isPanning = true
          // this.mesh.rotation.y += 4 * Math.PI / 360;
          modelsObjects.forEach((x) => x.rotation.y += 4 * Math.PI / 360 )

        })
        hammertime.on("panup", () => {
          if (!this.modelVisible) return;
          this.isPanning = true
          // this.mesh.rotation.x -= 4 * Math.PI / 360;
          modelsObjects.forEach((x) => x.rotation.x -= 4 * Math.PI / 360 )

        })

        hammertime.on("pandown", () => {
          if (!this.modelVisible) return;
          this.isPanning = true
          // this.mesh.rotation.x += 4 * Math.PI / 360;
          modelsObjects.forEach((x) => x.rotation.x += 4 * Math.PI / 360 )

        })
        hammertime.on("panend", () => this.isPanning = false)
        hammertime.on("pancancel", () => this.isPanning = false)

        hammertime.on("swipeleft",  ({velocity}) => {
          if (!this.modelVisible) return;
          this.swipeVelocity = velocity
        })
        hammertime.on("swiperight", ({velocity}) => {
          if (!this.modelVisible) return;
          this.swipeVelocity = velocity
        })
        hammertime.on("press", () => {
          if (!this.modelVisible) return;
          // this.desc.visible = this.desc.visible !== true;
          modelsDesc.forEach((x) => x.visible= x.visible !==true)
        })
      },
      tick: function() {
        if (!(this.modelVisible && this.swipeVelocity &&!this.isPanning)) return;
        this.mesh.rotation.y += this.swipeVelocity * 4 * Math.PI / 360;
        this.swipeVelocity *= 0.93;
        if (Math.abs(this.swipeVelocity) <= 0.1) this.swipeVelocity = 0;
      }
    })
  </script>
</head>

<body style="margin : 0px; overflow: hidden;">

<a-scene renderer="logarithmicDepthBuffer: true; colorManagement: true" vr-mode-ui="enabled: false" embedded arjs>
  <a-assets>
    <a-asset-item id="na-gltf" src="models/NA.gltf"></a-asset-item>
    <a-asset-item id="h-gltf" src="models/hydrogen.gltf"></a-asset-item>
  </a-assets>
  <a-marker type="pattern" url="nftCreated/pattern-Chlorine-A.patt" >
    <a-entity id="h-model" position="0 0 0" gltf-model="#h-gltf" scale="0.05 0.05 0.05" >
      <a-entity id="h-desc" position="0 1 0"  rotation="-90 0 0" text="value:  Hello World"  scale="15 15 15"></a-entity>
    </a-entity>
  </a-marker>
  <a-marker type="pattern" url="nftCreated/pattern-Sodium-A.patt" controller>
    <a-entity id="na-model" position="0 0 0" gltf-model="#na-gltf" scale="0.05 0.05 0.05" >
      <a-entity id="na-desc" position="0 1 0"  rotation="-90 0 0" text="value:  Hello World"  scale="15 15 15"></a-entity>
    </a-entity>
  </a-marker>
  <a-entity camera></a-entity>
</a-scene>
</body>

</html>